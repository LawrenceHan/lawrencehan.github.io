[{"content":"\n\n#### 配合音乐看，效果更好 ^_^\n\u003ciframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2\u0026id=33922453\u0026auto=1\u0026height=66\"\u003e\u003c/iframe\u003e\n\n## 一个简单的BFS实现\n\n![BFS路径图](/images/bfs3.png)\n\n**以下为伪代码:**\n\n**Queue:** 用来储存需要遍历的结点，FIFO先进先出。\n``` text\n假设我们从A点出发\n\nqueue.enqueue(A) // 把A点加入到队列，现在队列为 [ A ]\nqueue.dequeue() // 取出队列里第一个结点A，现在队列为 [ ]，(A被标记为已遍历，以下同)\nA的关联结点为B和C\nqueue.enqueue(B)\nqueue.enqueue(C) // 把B和C加入到队列， 现在队列为 [ B, C ]\n\nqueue.dequeue() // 取前队列里第一个结点B，现在队列为 [ C ]\nB的关联结点为D和E\nqueue.enqueue(D)\nqueue.enqueue(E) // 把D和E加入到队列， 现在队列为 [ C, D, E ]\n\nqueue.dequeue() // 取前队列里第一个结点C，现在队列为 [ D, E ]\nB的关联结点为F和G\nqueue.enqueue(F)\nqueue.enqueue(G) // 把F和G加入到队列， 现在队列为 [ D, E, F, G ]\n\nqueue.dequeue() // 取前队列里第一个结点D，现在队列为 [ E, F, G ]\nD没有关联结点\n\nqueue.dequeue() // 取前队列里第一个结点E，现在队列为 [ F, G ]\nE的关联结点为H\nqueue.enqueue(H) // 把H加入到队列， 现在队列为 [ F, G, H ]\n\nqueue.dequeue() // 取前队列里第一个结点F，现在队列为 [ G, H ]\nF没有关联结点\n\nqueue.dequeue() // 取前队列里第一个结点G，现在队列为 [ H ]\nG没有关联结点\n\nqueue.dequeue() // 取前队列里第一个结点H，现在队列为 [  ]\nH没有关联结点，至此遍历结束\n```\n我们遍历的顺序为: `A` `B` `C` `D` `E` `F` `G` `H` 如下图：\n![BFS遍历图](/images/bfs4.png)\n\n## 尝试遍历Puzzle\n![Puzzle遍历图](/images/bfs5.png)\n根据上图我们得到第一步的结点: `R1`和`R2`，但是第二步白格换位置了，于是我们得到\n`R2` `R3` `R4`三个结点。当称动到第三步时我们又得到`R1` `R3` `B3` `R5`四个结点。\n如果按照BFS的逻辑进行遍历的话，会有很多无效的step(每走的一步)。很且很容易走进死循环(想一想为什么)。\n所以我们需要在BFS的基础上进行一些`自定义的操作`。\n\n## 一个自定义的BFS\n首先我们先看以下两种情况:\n![重复的 step](/images/bfs6.png)\n![死循环 step](/images/bfs7.png)\n\n**第一种情况:**\n\n第二步和第四步的步数不同分别为step2和step4(废话，但是必须说)，但是图形完全一样。\n在这种情况下，我们需要把`曾经出现过的图形`保存起来，用来在走每一步时判断是否为重复的图形(因为同样的图形可能是由不同的step来产生的)。如果为重复的图形，那么这一步就弃掉不再加入到queue里进行遍历。\n\n**第二种情况:**\n\n以step2为原点，step1为前一步，step3为下一步。step1 == step3。当下一步等于前一步时，弃掉下一步。\n这样就可以避免死循环了。\n\n## 把图形抽像成string\n\n根据以上结论我们需要创建这样一个对象:\n``` swift\nprivate class Route: CustomStringConvertible {\n    \n    var previousStep: Int = 0\n    var nextStep: Int = 0\n    var frame: String\n    var stepsList: String\n    \n    init(previousStep: Int, nextStep: Int, frame: String) {\n        self.previousStep = previousStep;\n        self.nextStep = nextStep\n        self.frame = frame\n        self.stepsList = \"\"\n    }\n    \n    open var description: String {\n        return \"previous step: \\(previousStep), current step: \\(nextStep), frame: \\(frame), steps: \\(stepsList)\"\n    }\n}\n```\n`steplist`代表走过的每一步的方向。`e.g: 下，右 = Down, Right = DR`。\n这里的`Frame`要特别说明一下，在第一种情况下我们需要保存`曾经出现过的图形`，把这个概念抽像成`帧`，每走一步产生的图形即代表`一帧`。\n这里用`String`是因为取hash值验证比较方便。所以接下来我们就要定义如何用`string`来表示图形。\n\n白格子用`w(white)`表示，红格子用`r(red)`表示，蓝格子用`b(blue)`表示。那么我们可以得到以下string:\n``` text\nW R B B\nR R B B\nR R B B\nR R B B\n```\n简化后为:`WRBB RRBB RRBB RRBB` = `WRBBRRBBRRBBRRBB` = `wrbbrrbbrrbbrrbb`\n这样我们就可以推理出起始帧和结束帧:\n\nBegin Frame = `wrbbrrbbrrbbrrbb`\nEnd Frame = `wbrbbrbrrbrbbrbr`\n\n## 验证\n有了以上基础，我们就可以开始进行遍历了，但是每走一步我们都要进行如下验证：\n\n首先检查有没有越界，因为我们用的是\"wrbbrrbbrrbbrrbb\"这样的string\n第一行wrbb 第二行rrbb 第三行rrbb 第四行rrbb\n上下左右移动就相当于在strings这个字符串数组里换位置，比如上是当前index - 4,\n下是当前index + 4, 左是index - 1, 右是index + 1。\n\n因为起始在左上角，所以向上和向左都越界了\n我们先演示向下移动\n``` text\nlet index = 0\nvar nextIndex = index + 4\n\nwrbb rrbb rrbb rrbb\n*    ^\n\nrrbb wrbb rrbb rrbb\n^    *\n```\n其次，每一步的四个方向都遍历完后，验证是否已经有解了，这一步只要判断\n\n`rrbb wrbb rrbb rrbb` == `wbrb brbr rbrb brbr` 即\n`route.frame.hash` == `endFrame.hash`\n\n下面用伪代码来演示\n``` swift\nlet queue = Queue()\nlet beginRoute = Route()\nqueue.enqueue(beginRoute)\nlet route = queue.dequeue()\nlet currentStep = route.nextStep\nlet previousStep = route.previousStep\n\nvar nextStep = currentStep - 4 // upward\nif nextStep \u003e= 0 \u0026\u0026 nextStep != previousStep {\n    self.moveUp()\n}\n\nnextStep = currentStep + 4 // downward\nif nextStep \u003c self.totalBlockCount \u0026\u0026 nextStep != previousStep {\n    self.moveDown()\n}\n\nnextStep = currentStep - 1 // leftward\nif currentStep % self.columnCount - 1 \u003e= 0 \u0026\u0026 nextStep != previousStep {\n    self.moveLeft()\n}\n\nnextStep = currentStep + 1 // rightward\nif currentStep % self.columnCount + 1 \u003c self.columnCount \u0026\u0026 nextStep != previousStep {\n    self.moveRight()\n}\n\n// 因为向下和向右两步都成功了，产生了两个新的route\nlet newRoute1 = route.moveDown() \nqueue.enqueue(newRoute1) // 现在queue为 [ newRoute1 ]\nlet newRoute2 = route.moveRight()\nqueue.enqueue(newRoute2) // 现在queue为 [ newRoute1, newRoute2 ]\n\n// 然后继续遍历直到找到解为止\nlet route = queue.dequeue()\netc...\n\n```\n\n## References:\n[BFS by Swift Algorithm Club](https://github.com/raywenderlich/swift-algorithm-club/tree/master/Breadth-First%20Search)\n\n[Puzzle-iOS by Lawrence](https://github.com/LawrenceHan/Puzzle-iOS/blob/master/Puzzle_iOS/Puzzle_iOS/PuzzleSwift.swift)\n\n## 下一篇会讲一下算法的优化\n","cover":"/images/bfs2.png","link":"solving_puzzle_2.html","preview":"\u003cp\u003e系列文章第二篇，谈谈怎么实现BFS\u003c/p\u003e\n","title":"使用BFS算法来解决Puzzle（二）"},{"content":"\n\n## 前言\n\n本文是写于在`CocoaHeads Shanghai`12月的分享之后，演讲主题是`如何用BFS算法来解决一个Puzzle`。\n由于分享的时间有限，所以很多细节没有说清楚，想来想去还是写下来比较好，即对自己的知识进行梳理，也是和别人交流的一个机会。\n由于keynote和代码说明包括分享都是英文的，所以就用中文来写这个系列文章。\n\n## 规则\n\n[规则原地址说明](https://glowing.com/jobs/mobiledeveloper)\n\n首先你的起点是S图，每移动一次（上下左右四个方向）白色的方块都会和称动方向相邻的方块交换位置。\n经过**RDRDL**（U=上，D=下，L=左，R=右，下同）后变成E图。你的目标是用最少的步数变成T图。\n![规则说明图](/images/puzzle1.png)\n\n## 解题思路\n\n我首先想到的是有没有什么现成的数据结构和算法能解决这个问题？\n\n#### 解题思路（一）Graph\n\n什么是Graph呢？下面就是一个简单的Graph\n![Graph例图 1](/images/graph1.png)\n\n那么Graph有什么用呢？能解决什么问题呢？事实上Graph有用的**一批**啊。。。\n参照下图，我们把几个地点的飞机价格抽像成一个Graph如下图：\n![Graph例图 2](/images/graph2.png)\n\n**通过这个图，我们就可以很轻松的找到从New York到London的最便宜路线是哪一条了。**\n\n``` text\nSwift Algorithm Club:\nIf you have some programming problem where you can represent some of \nyour data as nodes and some of it as links between those nodes, then \nyou can draw your problem as a graph and use well-known graph algorithms \nsuch as breadth-first search or depth-first search to find a solution.\n```\n\n不过很遗憾，在了解了什么是Graph后，我发现这个数据结构并不适合用来解决这个问题。\n原因之一是：`每次白格移动时都会和旁边的格子交换位置`，这条规则会在白格每次移动时都会重建立Graph。\n这显然是得不偿失的。\n原因之二是：一共只有16个方格，这已经是非常简单的结构了，没有必要再次抽象成另外一种数据结构。\n\n#### 解题思路（二）BFS算法 (Breadth First Search)\n\n其实最开始我并没有首先想到BFS算法，我最先想到的是穷举法。\n我们来看这个图形，其中白色的格子1个，红色的格子7个，蓝色的格子8个，而且是4X4。\n那么它能产生的各种组合并不是很多。但是规则是不仅要找出解，还要求是最少步数。那么这里就需要用到\nBFS了。**Why?**\n\n``` text\nBreadth-first search is a method for traversing a tree or graph data structure. \nIt starts at a source node and explores the immediate neighbor nodes first, \nbefore moving to the next level neighbors. As a convenient side effect, \nit automatically computes the shortest path between a source node and each \nof the other nodes in the tree or graph.\n```\n\n![BFS遍历示意图](/images/bfs1.gif)\n\n从遍历示意图可以看出，BFS的特性就是优先遍历临近的结点(node)。这里我们可以认为每一次遍历都是走了一步。\n这样的话我们只要每走一步都去验证一下是不是已经找到解了就可以了，接下来就是实现BFS了。\n\n## 下一篇文章将会讨论如何实现BFS","cover":"/images/puzzle1.png","link":"solving_puzzle.html","preview":"\u003cp\u003e系列文章第一篇，目标是不烂尾\u0026hellip;\u003c/p\u003e\n","title":"使用BFS算法来解决Puzzle（一）"}]